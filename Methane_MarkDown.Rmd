---
title: "Methane in Hector"
author: "Natalie Crowe"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Building a Hector Core

Our first step is to create a core. Hector will use this to pull data from existing climate projections. Our projections will be from SSP245.

```{r  Hector-core, message=FALSE}
library(hector)
library(ggplot2)
library(dplyr)
ini_file <- system.file("input/hector_ssp245.ini", package = "hector")
core <- newcore(ini_file)
run(core)
```

## Methane Emissions Data and Graph

After creating and running the core we query it for methane-related outputs
between the years of 1745 and 2100. Hector has several options that relate to methane, including emissions, concentration, postindustrial, natural, soil lifetime and stratosphere lifetime.

```{r Emissions-data-frame}
results<- fetchvars(core, 1745:2100, c(EMISSIONS_CH4(), CONCENTRATIONS_CH4()))
head(results)
```

### Plot Results Methane Emissions

Now we have all the things we need to build a simple plot of methane emissions between the years 1745 and 2100. The `ggplot2` package is helpful for making graphs quickly and simply. We already loaded this package at the beginning of this file. 

```{r Emissions-plot}
results %>% 
  filter(variable == EMISSIONS_CH4()) %>% 
  ggplot(aes(x= year, y= value))+
    geom_line(color="blue")+
    labs(x = "Year",
         y = "Methane Emissions (Tg)",
         title = "Methane Emissions 1745-2100 in SSP245")
```

## Methane Concentrations

By changing the input `EMISSION_CH4()` to `CONCENTRATIONS_CH4()` we can replicate our code to get different visualized data.

```{r Concentration-graph}
results %>% 
  filter(variable == CONCENTRATIONS_CH4()) %>% 
  ggplot(aes(x= year, y= value))+
    geom_line(color= "red")+
    labs(x = "Year",
         y = "Methane Concentration (ppbv)",
         title = "Methane Concentration 1745-2100 in SSP245")
```

### Adding Another Dataframe
Let’s compare this data to NOAA’s data of yearly mean CH4 increase. We first have to read the file using read.table, then we can assign names to each column.
```{r noaa-data}
noaa<- read.table("noaa_data/ch4_annmean_gl.txt.txt", skip = 61)
noaa_data <- noaa %>%
  rename(year = V1, mean = V2, unc = V3) %>%
  select(-unc)

```

We then tell hector we want to look at CH4 concentration in the years corisponding to the NOAA data.

```{r hector-data}
hector_data <- results %>%
  filter(year %in% noaa_data$year,
         variable == "CH4_concentration") %>%
   select(year,
         mean = value)
```

We can then plot for the hector and NOAA data at once.

```{r NOAA-plot}
ggplot() +
  geom_line(data = noaa_data, aes(x = year, y = mean, color = "NOAA")) +
  geom_line(data = hector_data, aes(x = year, y = mean, color = "Hector")) +
  labs(x = "Year", 
       y = "ppb",
       color = "Source")
```


## Comparison Plots

We can put these two results into a single graph...
```{r Comparison-graph}
ggplot(data= results, aes(x= year, y= value, color= units))+
    geom_line()+
    labs(x = "Year",
         y = NULL,
         title = "Methane Concentration/Emission 1745-2100 in SSP245",
         color = "Units") + facet_wrap(~variable)
```
... to show our data side-by-side.

## Sensitivity Analysis

To examine SSP245's Natural methane  sensitivity we first ask hector to fetch data for the `NATURAL_CH4` constant. We then create a function to run this parameter set to a particular value. 

```{r call-for-param}
core <- newcore(ini_file)
run(core)
default<- fetchvars(core, NA, NATURAL_CH4())

param<- function(core, parameter, value) {
  old_value <- fetchvars(core, NA, parameter)
  unit <- as.character(old_value[["units"]])
  setvar(core, NA, parameter, value, unit)
  reset(core)
  run(core)
  result <- fetchvars(core, 2000:2100)
  result[["parameter_value"]] <- value
  result
}
```

Then we tell hector to run a range of values. In this case we ask for 20% above and bellow the set value of `NATURAL_CH4`(341Tg) at intervals of 5 +/-20%. These set values are labelled as `ch4-seq`.

```{r sen-param}
run_with_param_range <- function(core, parameter, values) {
  mapped <- Map(function(x) param(core, parameter, x), values)
  Reduce(rbind, mapped)
}
valuen<- default %>%
  select(value)
meann<- valuen$value
ch4_low <- meann * (1 - 0.2)
ch4_high <- meann * (1 + 0.2)
ch4_seq <- seq(ch4_low, ch4_high, 5)
sensitivity_emission <- run_with_param_range(core, NATURAL_CH4(), ch4_seq)
```

Once we have our differing model outputs we can create a graph. Using the graph function `facet_wrap`to separate the results based on variable. 

```{r sen-graph}
ggplot(sensitivity_emission) +
  aes(x = year, y = value, color = parameter_value, group = parameter_value) +
  geom_line() +
  facet_wrap(~variable, scales = "free_y") +
  labs(color = "NATURAL CH4 (Tg)") +
  scale_color_viridis_c() 
```

### Adding a Histogram 

Using the same `Natural_CH4` data, we can also make a histogram plot. Since we already made `ch4_low` and `ch4_high` with levels +/-20%, we can re-purpose them for this graph.

```{r rnorm}
sdn<- meann*0.2
data<- data.frame(value= rnorm(1000, meann, sdn))
```

Then we can use `ggplot2` to create a histogram with the randomized values.
```{r hist}
ggplot(data, aes(x=value))+
  geom_histogram(binwidth = 1)+
  labs( x= "Natural CH4 Level", y= "count", main= "Natural CH4 Histogram")
invisible(shutdown(core))
```


## Multiple Parameter Run

Working with two parameters `NATURAL_CH4` and `PREINDUSTRIAL_CH4` to create a sensitivity analysis. First we use `fetchvars` for both.

```{r core}
core <- newcore(ini_file)
run(core)
results <- fetchvars(core, NA, c(NATURAL_CH4(), PREINDUSTRIAL_CH4(),LIFETIME_SOIL(), LIFETIME_STRAT()))
```

We then create two data frames- one for each parameter. First isolating the variable, and then calculating mean and standard deviation for the variable's value. The using `rnorm` we create 1000 values pulled from the normal distribution, putting our results in `data.frame`.

```{r rnorm}
nat_value<- results %>%
  filter(variable== "CH4N") 
nat_mean<- nat_value$value
nat_sd<- nat_mean*0.2
nat_data<- data.frame(value= rnorm(10, nat_mean, nat_sd))

pre_value<- results %>%
  filter(variable== "M0") 
pre_mean<- pre_value$value
pre_sd<- pre_mean*0.2
pre_data<- data.frame(value= rnorm(10, pre_mean, pre_sd))

soil_value<- results %>%
  filter(variable== "Tsoil") 
soil_mean<- soil_value$value
soil_sd<- soil_mean*0.2
soil_data<- data.frame(value= rnorm(10, soil_mean, soil_sd))

strat_value<- results %>%
  filter(variable== "Tstrat") 
strat_mean<- strat_value$value
strat_sd<- strat_mean*0.2
strat_data<- data.frame(value= rnorm(10, strat_mean, strat_sd))
```

Combining the data frames with `bind.cols` and renaming the columns.

```{r data_frame}
data<- bind_cols(pre_data, nat_data, soil_data, strat_data) %>%
  as_tibble()
rows<- seq(nrow(data))
data<- data %>%
  mutate(new_col= rows)
colnames(data)<- c("PREINDUSTRIAL_CH4", "NATURAL_CH4", "LIFETIME_SOIL", "LIFETIME_STRAT", "run_number")
```

Using a `for` loop function, we can run both parameters of the data frame- read as different columns by our code. 

```{r function_mod}
multi_param <- function(core, pdata){ # create input for function
  for(p in colnames(pdata)) { # for each column name (parameter)...
    var<- do.call(p, list()) # create vector for row running; convert each column name (each parameter) to a function so that setvar() recognizes it
    old_value<- fetchvars(core, NA, var) # old variable called to access units to be used in setvar()
    unit<- as.character(old_value[["units"]]) # access units
    setvar(core, NA, var, pdata[p][[1]], unit) # set row vars from old to new values; note that pdata[p][[1]] accesses just the values in the p (parameter) column
    reset(core) # reset core to run new values
  }
  run(core) # run core with all new param values
  result<- fetchvars(core, 2000:2100) # results for x years
  result
}
```

To run our values through this new function, we create another `for ` loop to put in each row of data one by one. Then with `bind_rows` we can use these created values to form a data frame.

```{r output}
output<- list() #make an empty list
# loop starting with 1st row of data going from 1-end of data
for(rownum in 1:nrow(data)){ 
  # output as a row for inputs of all columns in row running(1-end data)
  # besides 5th ; assign the results of running the multi_param() function 
  # using our runlist to the output list. We don't use the 5th column 
  # (run_number) in the function, but rather as an identifier for each entry 
  # in the output list.
  output[[rownum]]<- multi_param(core, data[rownum,][-5])
  
  # now that row has finished without 5th row, put 5th row back in as guide 
  # for next row run ; note that output[[x]] accesses the xth element of the 
  # list, a data frame, and $run_number applies to that data frame. 
  output[[rownum]]$run_number<- data$run_number[[rownum]] 
}

output_data<- output %>% bind_rows() #create a data frame with output
full_data<- left_join(output_data, data, by= "run_number") #add in param values columns to results of loop df by pairing with run_number column
```

Similar to the graph in our first sensitivity analysis, we can form a graph using the `output_data` made in the last step. 

```{r graph}
ggplot(output_data) +
  aes(x = year, y = value, group = NATURAL_CH4, color= NATURAL_CH4) +
  geom_line() +
  facet_wrap(~variable, scales = "free_y") +
  labs(color = "NATURAL CH4 (Tg)") +
  scale_color_viridis_c()
shutdown(core)
```

